<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring 基本概念 | Gridea</title>
<link rel="shortcut icon" href="https://ljy-better.github.io/favicon.ico?v=1599480361944">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://ljy-better.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring 基本概念 | Gridea - Atom Feed" href="https://ljy-better.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="一、Spring 是什么？
1、Spring 是一种多层的 JavaEE 应用程序框架，其核心就是提供一种新的机制管理业务对象及其依赖关系
2、Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架
二、为什么要使用 S..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://ljy-better.github.io">
  <img class="avatar" src="https://ljy-better.github.io/images/avatar.png?v=1599480361944" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring 基本概念
            </h2>
            <div class="post-info">
              <span>
                2020-09-07
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>一、Spring 是什么？<br>
1、Spring 是一种多层的 JavaEE 应用程序框架，其核心就是提供一种新的机制管理业务对象及其依赖关系<br>
2、Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架</p>
<p>二、为什么要使用 Spring？<br>
1、降低组件之间的耦合度,实现软件各层之间的解耦。<br>
2、可以使用容器提供的众多服务<br>
3、容器提供单例模式支持，开发人员不再需要自己编写实现代码。<br>
4、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。<br>
5、容器提供的众多辅作类，使用这些类能够加快应用的开发<br>
6、Spring 对于主流的应用框架提供了集成支持</p>
<p>三、Spring 的核心及其组成</p>
<pre><code>1、核心就是提供一种新的机制管理业务对象及其依赖关系。IoC（控制反转）/ DI (依赖注入)，AOP（面向切面编程）。
    1.1 IoC: Inversion of Control (控制反转) ： 就是把要在程序中实例化的对象配置到文件中,在程序中不用new来产生，而是让容器通过配置文件返回一个给你，好处就是当需要更改业务逻辑时，方便替换对接口的不同实现类。
    1.2 AOP: Aspect Oriented Programming (面向切面编程) 用来在系统中提升业务的分离，把日志、安全、事务等东西和核心业务分离开,甚至核心业务都不知道它们的存在。基本实现就是对相关的方法进行拦截，添加所需的处理动作。

2、Spring 的七大组成模块
</code></pre>
<p>四、Spring 的特点<br>
1. 轻量级：</p>
<p>轻量级是针对重量级容器（EJB）来说的，Spring的核心包就不到1M大小。</p>
<pre><code>2. 非入侵式：
</code></pre>
<p>Spring目标是一个非入侵式的服务框架。原因是所有框架都是提供大量的功能供用户去使用，从而简化开发时间和成本，但由于大量的使用了框架的API，使应用程序和框架发生了大量的依赖性，无法从框架中独立出来，更加无法使程序组件在其他程序 中使用。</p>
<pre><code>3. 容器：
    3.1 Spring提供了容器功能，容器可以管理对象的生命周期、对象与对象间的关系、我们可以通过编写XML来设置对象关系和初始值，这样容器在启动之后，所有的对象都直接可以使用，不用编写任何编码来产生对象。

    3.2 Spring有两种不同的容器：
</code></pre>
<p>Bean工厂（org.springframework.beans.factory.BeanFactory）是最简单的容器（基本容器）</p>
<p>应用上下文（org.springframework.context.ApplicationContext）建立在Bean工厂基础之上，提供了系统构架服务</p>
<pre><code>4. IoC / DI：

    4.1 Spring 最核心的概念就是IoC（控制反转，所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 ），而他的另一个名字就是DI（依赖注 入，所谓依赖注入就是指：在运行期，由外部容器动态地将依赖对象注入到组件中。 ）。

    4.2 使用Spring我们不必在程序中维护对象的依赖关系，只要在XML中设定，Spring容器会自已根据相关的配置去产生他们之间的关系，相当于所有的关系都是在容器运行的时候注入的，而本身他们的关系是没有的。
</code></pre>
<ol start="5">
<li>
<p>AOP：</p>
<pre><code> 5.1 Spring 最被人重视的另一个方面就是对 AOP 的支持，其实 AOP 只是 Spring 支持的一个子容器

 5.2 AOP 在一个服务流程中插入与业务逻辑无关的系统服务逻辑，如：日志、权限验证、异常处理、事务等，而把这些独立出来设计成一个对象，这样的对象称为Aspect。
</code></pre>
</li>
<li>
<p>持久层：</p>
</li>
</ol>
<p>Spring 提供了对持久层的整合，如对 JDBC 的使用加以封装简化，提供事务功能，对 ORM 工具如 Hibernate 等的整合。</p>
<ol start="7">
<li>Web框架整合：</li>
</ol>
<p>Spring 也提供了 Web 的 MVC 解决方案，可以很好的善用 IOC 和 AOP 的功能，可以轻松的替换掉 View 层，如使用 JPS，也可以使用熟悉的 web 容器，如 struts 技术与 spring 整合。</p>
<p>五、Spring 的实现<br>
Spring Ioc 容器（ApplicationContext）负责创建 Bean，并通过容器将这些创建的Bean 注入到需要他们的消费者 Bean 中。Spring 提供使用 Xml、注解配置的方式创建和注入，容器解析这些配置信息进行 Bean 的初始化，配置和依赖管理。</p>
<p>（1）声明 Bean 的注解</p>
<p>@Componet 没有明确声明角色的功能<br>
@Service 在业务逻辑层使用<br>
@Repository 在数据操作层使用<br>
@Controller 在表现层（SpringMvc中）使用，其中 RestControlelr 也是一样的含义<br>
以上四个注解在功能是是相同的，他们唯一的区别只是从字面上了区分申明的 Bean 的功能。</p>
<p>（2）注入 Bean 的注解<br>
@Autowired<br>
@Injet<br>
@Resource<br>
以上三个注解的功能也是一样的，其中 @Autowired 是 Spring 提供的。</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://ljy-better.github.io/post/zhe-shi-yi-ge-ce-shi-wen-dang/">
              <h3 class="post-title">
                这是一个测试文档
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://ljy-better.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
